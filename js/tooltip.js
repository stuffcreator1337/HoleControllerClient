// Generated by CoffeeScript 1.6.3
/*
	https://github.com/TeamTypeform/Tooltip
*/


(function() {
  var __slice = [].slice;

  (function($, window) {
    var Tooltip;
    Tooltip = (function() {
      var $tail, $tip, tS, topWindow;

      Tooltip.prototype.defaults = {
        placement: 'top',
        content: '',
        trigger: 'hover',
        style: '',
        width: false,
        tip: true,
        delay: 0,
        border: false,
        selector: false
      };

      $tip = $("<div id='tip'><div></div></div>");

      $tail = $("<span>");

      topWindow = self;

      tS = true;

      function Tooltip(el, options) {
        var self;
        this.$el = $(el);
        self = this;
        this.options = $.extend({}, this.defaults, this.$el.data());
        this.options = $.extend({}, this.options, options);
        if (this.options.trigger === "hover") {
          this.$triggerEl = this.$el;
          if (this.options.selector) {
            this.$triggerEl = $(this.options.selector);
          }
          this.$triggerEl.on("mouseover.tip mousedown.tip mouseleave.tip", function(e) {
            if (e.type === "mouseover") {
              clearTimeout(tS);
              return tS = setTimeout(function() {
                return self.show();
              }, self.options.delay);
            } else {
              clearTimeout(tS);
              return self.hide();
            }
          });
        }
      }

      Tooltip.prototype.show = function() {
        while (topWindow.location !== topWindow.parent.location) {
          topWindow = topWindow.parent;
        }
        this.$tip = $(topWindow.document.body).find("#tip");
        if (!this.$tip.length) {
          this.$tip = $tip.clone().appendTo($(topWindow.document.body));
        }
        this.$tip.addClass(this.options.style);
        this.$tip.children("div").html(this.options.content);
        if (this.options.width) {
          this.$tip.children("div").css("width", this.options.width);
        }
        if (this.options.tip) {
          if (this.$tail1) {
            this.$tail1.remove();
          }
          this.$tail1 = $tail.clone().addClass("tail-1").appendTo(this.$tip);
        }
        if (this.options.border) {
          if (this.$tail2) {
            this.$tail2.remove();
          }
          this.$tail2 = $tail.clone().addClass("tail-2").appendTo(this.$tip);
        }
        this.setPosition();
        return setTimeout(function() {
          return $(topWindow.document.body).addClass("tooltip-show");
        }, 1);
      };

      Tooltip.prototype.hide = function() {
        $(topWindow.document.body).removeClass("tooltip-show");
        if (this.$tip) {
          return this.$tip.remove();
        }
      };

      Tooltip.prototype.destroy = function() {
        $(topWindow.document.body).removeClass("tooltip-show");
        if (this.$tip) {
          this.$tip.remove();
        }
        return this.$triggerEl.off(".tip");
      };

      Tooltip.prototype.setPosition = function() {
        var done, elH, elL, elT, elW, left, offsetLeft, offsetTop, placement, repositionToLeft, repositionToRight, tipH, tipW, top, wW;
        topWindow = self;
        done = false;
        while (!done) {
          $(topWindow.document.body).find("iframe").each(function(i, e) {
            var $e, isTf, isTinyMce, src;
            $e = $(e);
            src = $e.prop('src');
            isTf = src.indexOf('//admin.typeform') !== -1;
            isTinyMce = src.indexOf('javascript') !== -1;
            if (typeof src !== 'undefined' && (isTf || isTinyMce) || src === "") {
              return $e.contents().find("body").data({
                "offset-top": $e.offset().top,
                "offset-left": $e.offset().left
              });
            }
          });
          done = topWindow.location === topWindow.parent.location;
          topWindow = topWindow.parent;
        }
        topWindow = this.$el[0].ownerDocument.defaultView || this.$el[0].ownerDocument.parentWindow;
        done = false;
        offsetTop = 0;
        offsetLeft = 0;
        while (!done) {
          offsetTop += $(topWindow.document.body).data("offset-top") - topWindow.window.pageYOffset || 0;
          offsetLeft += $(topWindow.document.body).data("offset-left") - topWindow.window.pageXOffset || 0;
          done = topWindow.location === topWindow.parent.location;
          topWindow = topWindow.parent;
        }
        tipW = this.$tip.outerWidth();
        tipH = this.$tip.outerHeight();
        elW = this.$el.outerWidth();
        elH = this.$el.outerHeight();
        elL = this.$el.offset().left + offsetLeft;
        elT = this.$el.offset().top + offsetTop;
        wW = topWindow.document.documentElement.clientWidth;
        placement = this.options.placement;
        if (placement === "top" && elT - window.pageYOffset < tipH) {
          placement = "bottom";
        } else if (placement === "bottom" && elT - window.pageYOffset + elH + tipH > window.innerHeight) {
          placement = "top";
        }
        this.$tip.addClass(placement);
        switch (placement) {
          case "left":
            top = elT - (tipH - elH) / 2;
            left = elL - tipW;
            break;
          case "right":
            top = elT - (tipH - elH) / 2;
            left = elL + elW;
            break;
          case "bottom":
            top = elT + elH;
            left = elL - (tipW - elW) / 2;
            break;
          default:
            top = elT - tipH;
            left = elL - (tipW - elW) / 2;
        }
        repositionToLeft = Math.min(0, wW - tipW - left);
        repositionToRight = Math.min(left, 0);
        if (repositionToLeft) {
          repositionToLeft -= 3;
          this.$tip.children("span").css("left", -repositionToLeft + tipW / 2);
        }
        if (repositionToRight) {
          repositionToRight -= 3;
          this.$tip.children("span").css("left", repositionToRight + tipW / 2);
        }
        return this.$tip.css({
          top: top,
          left: left + repositionToLeft - repositionToRight
        });
      };

      Tooltip.prototype.set = function(option, value) {
        if (typeof option === 'string') {
          return this.options[option] = value;
        } else {
          return this.options = $.extend({}, this.options, option);
        }
      };

      return Tooltip;

    })();
    return $.fn.extend({
      tooltip: function() {
        var args, option;
        option = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
        return this.each(function() {
          var $this, data;
          $this = $(this);
          data = $this.data('tooltip');
          if (!data) {
            $this.data('tooltip', (data = new Tooltip(this, option)));
          }
          if (typeof option === 'string') {
            return data[option].apply(data, args);
          }
        });
      }
    });
  })(window.jQuery, window);

  $(function() {
    return $(".tooltip").tooltip();
  });

}).call(this);
